package antcolony.entities;

import antcolony.environment.FractalGenerator;
import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PVector;
import java.util.ArrayList;

/**
 * Represents a decorative tree in the environment.
 * <p>
 * The tree is composed of two parts:
 * 1. An underground root system (procedurally generated via Fractals/Julia Set).
 * 2. The trunk and canopy (recursively generated).
 * </p>
 */
public class StaticTree
{
    /**
     * Position of the trunk base (ground surface level).
     */
    public PVector root;

    /**
     * Base size of the tree (scale).
     */
    public float size;

    /**
     * List of positions where leaves will be drawn.
     * Calculated only once during generation to save performance.
     */
    public ArrayList<PVector> leafPositions = new ArrayList<>();

    /**
     * Random color variation to provide individuality to each tree.
     */
    public float colorOffset;

    /**
     * Root texture generated by the FractalGenerator.
     */
    public PGraphics rootTexture;

    /**
     * Current growth factor of the roots (0.0 to 1.0).
     * Used to animate roots growing at the start.
     */
    private float rootGrowth;

    /**
     * Growth rate of the roots.
     */
    private static final float GROWTH_RATE = 0.001f;

    /**
     * Static Tree Constructor.
     * @param p Reference to PApplet.
     * @param x X position.
     * @param y Y position (Ground level).
     * @param s Size/Scale.
     */
    public StaticTree(PApplet p, float x, float y, float s)
    {
        this.root = new PVector(x, y);
        this.size = s;
        this.colorOffset = p.random(-0.05f, 0.05f);
        
        // Starts with a partial size to avoid appearing instantly
        this.rootGrowth = p.random(0.25f, 0.45f);

        // Generates the branch and leaf structure (Recursive)
        // -PI/2 points upwards (90 degrees)
        generate(p, root.x, root.y, size, -PApplet.PI / 2, 0);

        // Generates the root texture using the external FractalGenerator
        int w = (int) (size * 2.5f);
        int h = (int) (size * 1.5f);
        
        this.rootTexture = FractalGenerator.createJuliaTexture(p, w, h);
    }

    /**
     * Updates the root growth animation.
     * @param dt Delta time.
     */
    public void updateRoots(float dt)
    {
        rootGrowth += GROWTH_RATE * dt;
        
        if (rootGrowth > 1.0f)
        {
            rootGrowth = 1.0f;
        }
    }

    /**
     * Generates the tree structure recursively (Basic Fractal Tree algorithm).
     * @param p Reference to PApplet.
     * @param x Current X position.
     * @param y Current Y position.
     * @param len Length of the current branch.
     * @param angle Current angle.
     * @param depth Recursion depth.
     */
    private void generate(PApplet p, float x, float y, float len, float angle, int depth)
    {
        // Base case: if the branch is too small, stop.
        if (len < 5)
        {
            return;
        }

        float x2 = x + PApplet.cos(angle) * len;
        float y2 = y + PApplet.sin(angle) * len;

        // If at a reasonable depth, add leaves
        if (depth > 2)
        {
            int count;
            
            // At the tips (depth > 4) add more leaves (4 to 8)
            // On middle branches, add fewer (1 to 3)
            if (depth > 4)
            {
                count = (int) p.random(4, 8);
            }
            else
            {
                count = (int) p.random(1, 3);
            }

            for (int i = 0; i < count; i++)
            {
                float r = p.random(len);
                float ang = p.random(PApplet.TWO_PI);
                
                // Adds a leaf at a random position around the branch
                float lx = x2 + PApplet.cos(ang) * r;
                float ly = y2 + PApplet.sin(ang) * r;
                
                leafPositions.add(new PVector(lx, ly));
            }
        }

        // Recursive calls for the two new branches (left and right)
        // Multiplies len by 0.7 to decrease size at each step
        generate(p, x2, y2, len * 0.7f, angle + PApplet.PI / 6, depth + 1);
        generate(p, x2, y2, len * 0.7f, angle - PApplet.PI / 6, depth + 1);
    }

    /**
     * Draws the complete tree.
     * @param p Reference to PApplet.
     * @param leafColor Leaf color (changes with the season).
     * @param seasonIdx Current season index (used to simulate leaf fall).
     * @param rootColor Root color (for tinting).
     */
    public void display(PApplet p, int leafColor, int seasonIdx, int rootColor)
    {
        // 1. Draw Roots (Julia Set Texture)
        if (rootTexture != null)
        {
            p.pushMatrix();
            
            float drawX = root.x - rootTexture.width / 2f;
            float drawY = root.y;

            p.translate(drawX, drawY);
            
            // Y scale controls the vertical growth animation
            p.scale(1.0f, rootGrowth);

            p.tint(rootColor);
            p.image(rootTexture, 0, 0);
            p.noTint();

            p.popMatrix();
        }

        // 2. Draw Trunk (Recursive in real-time)
        drawTrunk(p, root.x, root.y, size, -PApplet.PI / 2);

        // 3. Draw Leaves
        p.noStroke();
        p.fill(leafColor);

        // Winter Logic:
        // If it is Winter (idx 3), we draw only 1 in every 3 leaves
        // to simulate leaf fall without destroying the original array.
        int skip;
        if (seasonIdx == 3)
        {
            skip = 3;
        }
        else
        {
            skip = 1;
        }

        for (int i = 0; i < leafPositions.size(); i += skip)
        {
            PVector lp = leafPositions.get(i);
            p.ellipse(lp.x, lp.y, 8, 6);
        }
    }

    /**
     * Recursive helper method to draw trunk lines.
     */
    private void drawTrunk(PApplet p, float x, float y, float len, float angle)
    {
        if (len < 5)
        {
            return;
        }

        // Wood color (Dark brown)
        p.stroke(60, 40, 20);
        
        // Branch thickness decreases with length
        p.strokeWeight(len / 6);

        float x2 = x + PApplet.cos(angle) * len;
        float y2 = y + PApplet.sin(angle) * len;

        p.line(x, y, x2, y2);

        drawTrunk(p, x2, y2, len * 0.7f, angle + PApplet.PI / 6);
        drawTrunk(p, x2, y2, len * 0.7f, angle - PApplet.PI / 6);
    }
}